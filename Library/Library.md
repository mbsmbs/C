# 나만의 라이브러리 만들기
- 오브젝트 파일을 모아 라이브러리로 만듦
- 다시 컴파일할 필요 없이 코드 재활용이 가능
- 소스 코드 공개 없이 라이브러리 배포가능 (헤더 파일은 예외 무슨 함수가 있는지 알아야 하니까)
- C에서는 2종류의 라이브러리를 만들 수 있다:
  - 정적 라이브러리
  - 동적 라이브러리

## 정적 라이브러리와 링크
- 정적 라이브러리와 링크하는 것을 정적 링킹이라고 함
- 라이브러리 안에 있는 기계어를 최종 실행파일에 가져다 복사함
- 동적 링킹에 비해:
  - 실행 파일의 크기가 커짐
  - 메모리를 더 잡아먹을 수 있음
  - 실행 속도가 빠름
  
### 정적 라이브러리 사용하는 절차 : 282
1. 소스 코드들을 컴파일하여 정적 라이브러리를 만듦
- 보통 파일 하나
- 물론 여러 개의 라이브러리를 만들면 파일도 여럿
- 확장자는 *.lib(윈도우 비주얼 스튜디오)또는 *.a(리눅스 계열)
- 참고로 리눅스 계열에서는 아카이브(archive)라고도 함

2. 다른 소스 코드들을 작성할 때 위 라이브러리의 헤더 파일들을 사용
- 실행 파일을 만들기 위해 main() 함수를 가지고 있는 게 보통
- 여기의 소스 코드들이 바뀌어도 정적 라이브러리를 다시 만들 필요 없음

3. 컴파일 할 때 정적 라이브러리와 함께 링킹

### llvm-ar
llvm-ar -명령어<modifier> 정적_라이브러리_파일 <o파일들>
- 명령어:
  - r: 정적_라이브러리_파일 에 o파일들 추가
  - d: 정적_라이브러리_파일 에서 o파일들 삭제
- modifier (선택):
  - 각 명령어마다 사용할 수 있는 modifier가 다름
  - c: 정적 라리브러리 파일이 처음 만들어질 때 경고 메시지 출력 안 함
  

## 동적 라이브러리와 링크
- 동적 라이브러리와 링크하는 것을 동적 링킹이라고 함
- 실행파일 안에 여전히 구멍을 남겨두는 방법
- 실행파일을 실행할 때 실제로 링킹이 일어남
  - 이 링킹은 실행 중에 운영체제가 해 줌
- 정적 링킹에 비해:
  - 실행파일 크기가 적다
  - 여러 실행파일이 동일한 라이브러리를 공유할 수 있다. -> 메모리 절약
  - 여러 실행파일이 이름은 같지만 버전이 다른 동적 라이브러리를 사용한다면 DLL 지옥을 맞볼 수 있다.
  
### 동적 라이브러리를 사용하는 절차
1. 소스 코드들을 컴파일하여 동적 라이브러리를 만듦
- 파일 하나
- 확장자 : *.dll(윈도우) 또는 *.so(리눅스 계열)
 
2. 다른 소스 코드들을 작성할 때 위 라이브러리의 헤더 파일들을 사용

3. 컴파일 할 때 동적 라이브러리와 함께 링킹
- 단, 동적 라이브러리에 있는 기계어가 실행파일에 포함되지 않음
- 실행 중에 동적으로 링킹할 수 있는 정보만 포함
- 따라서 동적 라이브러리 파일도 같이 배포
  
### 동적 라이브러리와 운영체제 : 283


## 동적 라이브러리의 장단점:
- 장점 :
  - 실행파일을 바꾸지 않고 동적 라이브러리 파일만 업데이트 가능
  - 동적 라이브러리 파일을 바꾸지 않고 실행파일만 업데이트 가능
  - 필요에 따라 동적 라이브러리를 선택적으로 로딩 가능
    - 예: CPU세대 별로 동적 라이브러리 파일을 만들어 둠
    
- 단점 :
  - 해킹 당하기 쉬움. DLL 인젝션
    - 라이브러리 안에 있는 함수의 메모리 주소가 동적으로 링킹 되기 때문
  - DLL 지옥
  
## 정적 라이브러리의 장단점
- 장점:
  - 함수의 주소가 공개 안 되니 보다 안전
  - 정확한 버전의 라이브러리가 실행파일 안에 배포되어있음
  - 최적화에 유리

- 단점:
  - CPU 세대 별로 실행파일을 만들어서 배포해야 함
  - 라이브러리의 소스 코드가 바뀔 때마다 실행파일을 재배포해야 함
    - 실행파일의 소스코드가 바뀔 때도 마찬가지
  - 실행파일의 크기가 커짐
  - 실행 중 다른 실행파일들과 라이브러리 공유 불가
  
  
## 베스트 프랙티스 : 기본적으로 정적 라이브러리를 쓰자.

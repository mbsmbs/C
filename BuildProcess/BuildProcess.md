# C 빌드 과정
- Build
  - 소스코드를 기계 명령어로 변환 하는 과정
  - 그 명령어들을 모아 실행파일을 만드는 과정
- 4 단계로 나뉘어짐:
  1. Preprocessing
  2. Compilation
  3. Assembling
  4. Linking
  
  ## .h와 .c파일
  
  ### .h 파일
  - 여러 소스코드 파일에 공통적으로 필요한 것들을 저장해 두는 파일
  - 함수 선언, 매크로, extern 변수 선언 등
  - 소스 파일에서 #include로 가져다 사용할 수 있음
  
  ### .ㅊ 파일
  - 프로그램이 돌게 하는 로직 코드를 저장하는 파일
  - 함수 정의, 전역 변수, 매크로
  
  ### 헤더 파일에 함수 선언을 해놓고 여러 c파일에서 공유가능
  
  ## #include<> : 
  - 시스템 경로에서만 헤더 파일을 검색
  - 보통 컴파일러가 제공하는 시스템 헤더 파일을 인클루드 할 때
  
  ## #include "" : 
  - 현재 작업중인 디렉터리에서 헤더 파일을 먼저 검색한 뒤 없으면 시스템 경로를 검색
  - 개발자가 구현한 헤더 파일들을 인클루드할 때 사용
  
  
  
  
  ## A. 전처리 단계 : 전처리기(Preprocessor)라는 프로그램이 담당
  1. 입력 : c파일 하나
  2. 주석 제거
  3. 매크로 복붙
  4. 인클루드 파일들을 복붙
  5. 출력 : 확장된 소스코드  --> Translation unit
  
  ### Translation Unit 보는 방법
  - clang 컴파일 중에 -E플래그를 넣으면 됨
  ```
  > clang -std=c89 -W -Wall -pedantic-errors -E file.c
  ```
  - 파일로 저장해서 보려면 출력 리디렉션(output redirection)을 쓰면 됨
  ```
  > clang -std=c89 -W -Wall -pedantic-errors -E file.c > file.pre
  ```
  
  
  ## B. 컴파일 단계 : Compiler라는 프로그램이 담당
  1. 입력 : Translation Unit
  2. 출력 : 어셈블리어 코드
    - 어셈블리어 코드는 아직 정의를 모르는 함수나 변수의 이름등을 사용할 수 있음
    - 이래서 헤더를 통한 선언만으로 컴파일이 가능한 이유
    - 컴파일러가 어떤 함수나 변수의 정의를 몾 찾을 경우
    - 선언만 보고 어딘가에 있겠지, 링커가 채워주겠지하고 일단 구멍을 남긴다.
  
  ### 어셈블리어 코드 보는 방법
  - 컴파일 플래그 -S를 쓰면 .s파일로 저장됨
  ```
  > clang -std=c89 -W -Wall -pedantic-errors -S file.c
  ```
  ### 어셈블리어 코드가 나왔다는 의미는?
  - 이 단계 이후부터 코드는 특정 플랫폼에서만 동작한다는 이야기
  - C가 크로스 플랫폼이라는 주장은 컴파일되기 전까지만 임
  - 또한 타겟 플래폼이 몇 비트냐에 따라 C의 자료형 크기가 달라질 수 있다.
  - 어셈블리어 코드는 이미 그 자료형 크기가 결정된 후임
  
  
  ## C. 어셈블 단계 : Assembler라는 프로그램이 담당
  1. 입력 : 어셈블리어 코드
  2. 출력 : 오브젝트 코드
  
  ### 오브젝트 코드
  - 기계가 곧바로 이해 가능한 기계코드
  - 기계어
  - 이진코드
  - 어셈블리어 코드와 마찬가지로 여전히 메꿔야 하는 구멍이 있음
  
  ### 오브젝트 코드 보븐 방법
  - -c 플래그를 넣으면 .o 파일로 저장
  ```
  > clang -std=c89 -W -Wall -pedantic-errors -c file.c
  ```
  
  
  ## D. 링크 단계 : Linker라는 프로그램이 담당
  1. 입력 : 모든 오브젝트 코드들
  2. 링커는 오브젝트 코드들을 모아다 구멍을 메꾼 뒤 실행파일로 저장
    a. 링커가 오브젝트 파일을 다 모아서 하나의 이진 파일로 만들어 주다가 함수의 위치를 지억하고 있다가
    b. 함수를 호출하려는 코드를 만나면 실행위치에 실행위치에 아까 그 위치(주소)로 점프하는 코드를 넣어줌
    c. 다른 오브젝트 코드에서 정의를 못 찾았다면 링커는 못 찾는다며 링커 오류를 뱉음
  3. 출력 : 최종 실행파일 (.exe, .out)
  
  
  ## 왜 컴파일과 링크를 2단계로 나눠서 볼까?
  - 컴파일할 때마다 구멍을 메꾸기엔 너무 복잡
  - 비주얼 스튜디오에서는 기본적으로 오브젝트 파일과 .exe파일을 모드 만들어 줌
  - clang : .o파일로 .exe파일 만들기
  ```
  > clang -std=c89 -W -Wall -pedantic-errors file1.o file2.o
  > clang -std=c89 -W -Wall -pedantic-errors *.o
  ```

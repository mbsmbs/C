# C 빌드 과정
- Build
  - 소스코드를 기계 명령어로 변환 하는 과정
  - 그 명령어들을 모아 실행파일을 만드는 과정
- 4 단계로 나뉘어짐:
  1. Preprocessing
  2. Compilation
  3. Assembling
  4. Linking
  
## .h와 .c파일

### .h 파일
- 여러 소스코드 파일에 공통적으로 필요한 것들을 저장해 두는 파일
- 함수 선언, 매크로, extern 변수 선언 등
- 소스 파일에서 #include로 가져다 사용할 수 있음

### .ㅊ 파일
- 프로그램이 돌게 하는 로직 코드를 저장하는 파일
- 함수 정의, 전역 변수, 매크로

### 헤더 파일에 함수 선언을 해놓고 여러 c파일에서 공유가능

## #include<> : 
- 시스템 경로에서만 헤더 파일을 검색
- 보통 컴파일러가 제공하는 시스템 헤더 파일을 인클루드 할 때

## #include "" : 
- 현재 작업중인 디렉터리에서 헤더 파일을 먼저 검색한 뒤 없으면 시스템 경로를 검색
- 개발자가 구현한 헤더 파일들을 인클루드할 때 사용




## A. 전처리 단계 : 전처리기(Preprocessor)라는 프로그램이 담당
1. 입력 : c파일 하나
2. 주석 제거
3. 매크로 복붙
4. 인클루드 파일들을 복붙
5. 출력 : 확장된 소스코드  --> Translation unit

### Translation Unit 보는 방법
- clang 컴파일 중에 -E플래그를 넣으면 됨
```
> clang -std=c89 -W -Wall -pedantic-errors -E file.c
```
- 파일로 저장해서 보려면 출력 리디렉션(output redirection)을 쓰면 됨
```
> clang -std=c89 -W -Wall -pedantic-errors -E file.c > file.pre
```


## B. 컴파일 단계 : Compiler라는 프로그램이 담당
1. 입력 : Translation Unit
2. 출력 : 어셈블리어 코드
  - 어셈블리어 코드는 아직 정의를 모르는 함수나 변수의 이름등을 사용할 수 있음
  - 이래서 헤더를 통한 선언만으로 컴파일이 가능한 이유
  - 컴파일러가 어떤 함수나 변수의 정의를 몾 찾을 경우
  - 선언만 보고 어딘가에 있겠지, 링커가 채워주겠지하고 일단 구멍을 남긴다.

### 어셈블리어 코드 보는 방법
- 컴파일 플래그 -S를 쓰면 .s파일로 저장됨
```
> clang -std=c89 -W -Wall -pedantic-errors -S file.c
```
### 어셈블리어 코드가 나왔다는 의미는?
- 이 단계 이후부터 코드는 특정 플랫폼에서만 동작한다는 이야기
- C가 크로스 플랫폼이라는 주장은 컴파일되기 전까지만 임
- 또한 타겟 플래폼이 몇 비트냐에 따라 C의 자료형 크기가 달라질 수 있다.
- 어셈블리어 코드는 이미 그 자료형 크기가 결정된 후임


## C. 어셈블 단계 : Assembler라는 프로그램이 담당
1. 입력 : 어셈블리어 코드
2. 출력 : 오브젝트 코드

### 오브젝트 코드
- 기계가 곧바로 이해 가능한 기계코드
- 기계어
- 이진코드
- 어셈블리어 코드와 마찬가지로 여전히 메꿔야 하는 구멍이 있음

### 오브젝트 코드 보븐 방법
- -c 플래그를 넣으면 .o 파일로 저장
```
> clang -std=c89 -W -Wall -pedantic-errors -c file.c
```


## D. 링크 단계 : Linker라는 프로그램이 담당
1. 입력 : 모든 오브젝트 코드들
2. 링커는 오브젝트 코드들을 모아다 구멍을 메꾼 뒤 실행파일로 저장
  a. 링커가 오브젝트 파일을 다 모아서 하나의 이진 파일로 만들어 주다가 함수의 위치를 지억하고 있다가
  b. 함수를 호출하려는 코드를 만나면 실행위치에 실행위치에 아까 그 위치(주소)로 점프하는 코드를 넣어줌
  c. 다른 오브젝트 코드에서 정의를 못 찾았다면 링커는 못 찾는다며 링커 오류를 뱉음
3. 출력 : 최종 실행파일 (.exe, .out)


## 왜 컴파일과 링크를 2단계로 나눠서 볼까?
- 컴파일할 때마다 구멍을 메꾸기엔 너무 복잡
- 비주얼 스튜디오에서는 기본적으로 오브젝트 파일과 .exe파일을 모드 만들어 줌
- clang : .o파일로 .exe파일 만들기
```
> clang -std=c89 -W -Wall -pedantic-errors file1.o file2.o
> clang -std=c89 -W -Wall -pedantic-errors *.o
```

## 라이브러리로도 빌드할 수 있다.
- 실행파일이 아니라 라이브러리 파일이 나오게 할 수도 있다.
- 함수 등을 기계어로 변환 후 파일 하나로 저장해 놓은 것
- 다른 .c파일에서 이 기능들이 필요할 때 같이 링크해서 쓸 수 있음
- 라이브러리는 2가지 종류가 있는데:
  - 정적 라이브러리
  - 동적 라이브러리
  
### 정적 라이브러리
- 라이브러리안에 있는 기계어를 최종 실행파일에 가져다 복사함
- 동적 링킹에 비해
  - 실행파일의 크기가 커짐
  - 메모리를 더 잡아먹을 수 있음
  - 실행 속도가 빠름
  
### 동적 라이브러리 (.dll 파일)
- 실행파일안에 여전히 구멍을 남겨둔다
- 실행파일을 실행할 때 실제로 링킹이 일어남
  - 이 링킹은 실행 중에 운영체제가 해 줌
- 정적 링킹에 비해
  - 실행파일 크기가 적다
  - 여러 실행파일이 동일한 라이브러리를 공유할 수 있다 -> 메모리 절약
  - 여러 실행파일이 이름은 같지만 버전이 다른 동적 라이브러리를 사용한다면 DLL지옥을 맞볼 수 있다.
  
## 분할 컴파일
1. 2개 이상의 .c 파일을 개별적으로 컴파일해서 오브젝트 파일을 만듦
2. 오브젝트 파일들을 서로 연결시켜(링크해서) 실행파일을 만듦

### 다른 파일에 있는 전역변수 사용 시 문제점
- 컴파일러가 각 .c파일을 따로따로 컴파일 하기 때문
- main.c파일은 다른 .c파일안에 있는 지역변수의 존재를 모름
- 만약 두파일들안에 같은 변수가 존재한다면 같은이름의 변수를 쓴다고 링크단계에서 에러가난다.
- 따라서 새로운 전역변수를 만드는 게 아니라 어떤 특정 .c파일안에 있는 것을 가져다 쓸 거다라고 컴파일러에게 알려줘야함
- 그래야 컴파일러가 구멍을 비워 놓음

### 컴파일러에게 알려줄 때 : extern 사용 : 78 ~ 79
```c
extern int var;
```
- 다른 파일에 있는 전역 변수에 접근하려면 extern키워드를 사용
- 헤더에 넣는 것과 c파일에 넣는 것의 차이
  - 헤더 파일에 넣는 것은 누구라도 쓸 수 있게 해주는 것
  - c파일에 넣는 것은 그 파일 안에서만 쓰려고 하는 것
  
### 전역 변수의 문제
- extern 사용하면 아무데서나 다 확인 가능하고
- 맘대로 내 파일 안의 변수를 바꿔버림
- 파일이 여러개면 어디서 바꾸는지 알 수 가 없음
- 파일 안에서만 쓰려면 전역 변수 만들 때 static 사용

### static
- 다른 파일에서 전역 변수에 접근 못하게 막는 법
- 범위가 파일로 한정됨
- 정적 변수
- 다른 파일에서 접근 하면 링크 오류
- 함수안에 지역변수에도 사용하면 함수 안에서만 접근 가능


## c와 h파일 정리
1. 헤더 파일에는 선언만 들어간다
  - 함수 선언
  - 전역 변수 extern 선언
2. c파일에는 정의가 들어간다
  - 함수 정의
  - 전역 및 정적 변수 정의

## 순환 헤더 인클루드 (Circular Header Include) : 헤더 꼬임 해결법
- #include는 가능하면 c파일에서만 하기
- b 헤더에서 a 헤더를 인클루드 하는 대신 a에 정의된 것을 전방 선언하기
- 하지만 어쩔 수 없이 헤터 파일을 서로 인클루드해야 할 일이 있음
 - #define이 필요한 경우
-  인클루드 가드 사용 : #ifndef...#define...#endif


## C 컴파일러들
- GCC
- MS Visual C++
- Clang
- ...
